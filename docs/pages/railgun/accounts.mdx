# Accounts

:::info
TODO: Write intro
:::

## Setup

### Generate a BIP39 Mnemonic

:::code-group

```ts filename="viem.ts" twoslash [Viem]
// @noErrors
import { english, generateMnemonic } from 'viem/accounts'

const mnemonic = generateMnemonic(english) // [!code focus]
const accountIndex = 0
```

```ts filename="raw.ts" twoslash [Raw]
// @noErrors
const mnemonic = 'test test test test test test test test test test test test test junk'
const accountIndex = 0
```

:::

### Initialize Account and Indexer

Putting it all together

```ts twoslash filename="result.ts"
// @noErrors
import { createRailgunAccount, createRailgunIndexer, ViemProviderAdapter, RAILGUN_CONFIG_BY_CHAIN_ID } from '@kohaku-eth/railgun'
import { createPublicClient, http } from 'viem'

const mnemonic = 'test test test test test test test test test test test junk'
const accountIndex = 0
const chainId = '11155111' as const
const network = RAILGUN_CONFIG_BY_CHAIN_ID[chainId]

// Create a provider first
const publicClient = createPublicClient({
  transport: http('https://sepolia.rpc.example'),
})

// Create the indexer
const indexer = await createRailgunIndexer({
  network,
  provider: new ViemProviderAdapter(publicClient),
})

// Create the account with specified signer and indexer
const account = await createRailgunAccount({
  credential: { type: 'mnemonic', mnemonic, accountIndex },
  indexer,
});

// Sync the indexer to the latest block
await indexer.sync()
```

### Get 0zk Address

Every railgun account has a 0zk address that can be used to receive and send tokens.

:::code-group

```ts twoslash [address.ts] filename="address.ts"
import { account } from './config.ts'

const zkAddress = await account.getRailgunAddress();
// 0zk
```

```ts twoslash [config.ts] filename="config.ts"
import { createRailgunAccount, createRailgunIndexer, ViemProviderAdapter, RAILGUN_CONFIG_BY_CHAIN_ID } from '@kohaku-eth/railgun';
import { createPublicClient, http } from 'viem';

const mnemonic = 'test test test test test test test test test test test junk'
const chainId = '11155111' as const
const network = RAILGUN_CONFIG_BY_CHAIN_ID[chainId]

const indexer = await createRailgunIndexer({
  network,
  provider: new ViemProviderAdapter(createPublicClient({ transport: http('https://sepolia.rpc.example') })),
})

export const account = await createRailgunAccount({
  credential: { type: 'mnemonic', mnemonic, accountIndex: 0 },
  indexer,
});
```

:::

You can now receive funds to this address, see [Transacting](/railgun/txs) for more details.

## Getting Balances

```ts twoslash
// @noErrors
import { createRailgunIndexer, createRailgunAccount, ViemProviderAdapter } from '@kohaku-eth/railgun';
import { createPublicClient, http } from 'viem';


const chainId = '11155111' as const
const network = RAILGUN_CONFIG_BY_CHAIN_ID[chainId]
const startBlock = 4495479
const mnemonic = 'test test test test test test test test test test test junk'

// Get current block
const publicClient = createPublicClient({
  transport: http('https://sepolia.rpc.example'),
});
const endBlock = await publicClient.getBlockNumber()

// Create indexer and sync
const indexer = await createRailgunIndexer({
  network,
  provider: new ViemProviderAdapter(publicClient),
});

// Create account
export const account = await createRailgunAccount({
  credential: { type: 'mnemonic', mnemonic, accountIndex: 0 },
  indexer,
});

await indexer.sync();

// Get balance - optional token parameter (undefined = native gas token balance)
const balance = await account.getBalance();
```

### Syncing Merkle Roots

```ts twoslash
// @noErrors
import { ByteUtils, createRailgunAccount, createRailgunIndexer, ViemProviderAdapter } from '@kohaku-eth/railgun';

const mnemonic = 'test test test test test test test test test test test junk'
const accountIndex = 0

export const publicClient = createPublicClient({
  transport: http('https://sepolia.rpc.example'),
});

export const indexer = await createRailgunIndexer({
  network,
  provider: new ViemProviderAdapter(publicClient),
});

export const account = await createRailgunAccount({
  credential: { type: 'mnemonic', mnemonic, accountIndex },
  indexer,
});

await indexer.sync();

const root = await indexer.getLatestMerkleRoot();
console.log('latest merkle root:', ByteUtils.hexlify(root, true));
```

### Storage Considerations

To sync faster you could retain the previously indexed receipts. And re-use them in future syncs to save having to re-index.
Railgun syncing happens incrementally, as such you can store previous receipts to speed up future syncs.
